<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - instancing - raycast</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>
    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let camera, scene, renderer, controls;
        let geometry, material, mesh;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        const color = new THREE.Color();
		const white = new THREE.Color().setHex(0xffffff);
        init();
        animate();

        function init() {
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);

            scene = new THREE.Scene();

            const light = new THREE.HemisphereLight(0xffffff, 0x888888);
            light.position.set(0, 1, 0);
            scene.add(light);

            geometry = new THREE.IcosahedronGeometry(0.5, 3);
            material = new THREE.MeshPhongMaterial({ color: 0xffffff });
            
            mesh = new THREE.InstancedMesh(geometry, material, 4);
            
            const matrix0 = new THREE.Matrix4();
            matrix0.setPosition(0, 0, 0);
            const matrix1 = new THREE.Matrix4();
            matrix1.setPosition(1, 0, 0);
            const matrix2 = new THREE.Matrix4();
            matrix2.setPosition(0, 1, 0);
            const matrix3 = new THREE.Matrix4();
            matrix3.setPosition(0, 0, 1);
            
            mesh.setMatrixAt(0, matrix0);
            mesh.setMatrixAt(1, matrix1);
            mesh.setMatrixAt(2, matrix2);
            mesh.setMatrixAt(3, matrix3);
            
            scene.add(mesh);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enablePan = false;
            controls.enableDamping = true;
            controls.enableZoom = false;

            document.addEventListener('mousemove', onMouseMove);
        }

        function onMouseMove() {
            event.preventDefault();
			mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            raycaster.setFromCamera(mouse, camera); // (鼠标二维坐标, 摄像机)
            const intersection = raycaster.intersectObject(mesh); // 被射线贯穿的实例, 射线可穿透物体所以可能有多个
            if (intersection.length > 0) { // 但是鼠标移开之后射线不再穿过物体就不该再大于0, 为什么还会执行?
                const instanceId = intersection[0].instanceId; // 但是第0个肯定是最靠近放射源的那个实例
                mesh.getColorAt(instanceId, color);
                if (color.equals(white)) { // 检查当前物体颜色是否为白色, 如果不是, 那么变色
                    mesh.setColorAt(instanceId, color.setHex(Math.random() * 0xffffff));
                    mesh.instanceColor.needsUpdate = true;
                }
            }
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>
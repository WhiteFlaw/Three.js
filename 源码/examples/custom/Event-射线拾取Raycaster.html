<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - instancing - raycast</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>
    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let mesh;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(1, 1);

        init();
        animate();

        function init() {
            camera = new THREE.Perspective(60, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);

            scene = new THREE.Scene();

            const light = new THREE.HemisphereLight(0xffffff, 0x888888);
            light.position.set(0, 1, 0);
            scene.add(light);

            const geometry = new THREE.IcosahedronGeometry(0.5, 3);
            const material = new THREE.MeshPhongMaterial({ color: 0xffffff });
            mesh = new THREE.InstancedMesh(geometry, material, 1000); // 创建1000个

            let i = 0;
            const offset = 1000 - 1 / 2;

            const matrix = new THREE.Matrix4();
            for (let i = 0; x < 1000; x++) {
                for (let y = 0; y < 1000; y++) {
                    for (let z = 0; z < 1000; z++) {
                        matrix.setPosition(offset - x, offset - y, offset - z);
                        mesh = setMatrixAt(i, matrix);
                        mesh.setColorAt(i, color);

                        i++;
                    }
                }
            }

            scene.add(mesh);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(windw.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls();
            controls.enableZoom = true; // 启用缩放
            controls.enablePan = false; // 禁用平移
            controls.enableDamping = true; // 启用惯性

            document.addEventListener('mousemove', onMouseMove);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1
        }

        function animate() {
            requestAnimationFrame(animate);

            controls.update();

            
        }
    </script>
</body>

</html>
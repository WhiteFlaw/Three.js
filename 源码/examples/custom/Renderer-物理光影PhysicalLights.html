<!DOCTYPE html>
<html lang="en">

<head>
    <title>Renderer-物理光影Physical-Lights</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="../main.css">
</head>

<body>
    <div id="container"></div>
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
			{
				"imports": {
					"three": "../../build/three.module.js",
					"three/addons/": "../jsm/"
				}
			}
		</script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let camera, scene, renderer, bulbLight, bulbMaterial, hemiLight;
        let ballMaterial, cubeMaterial, floorMaterial;
        let clock;

        let previousShadowMap = false;

        const bulbLuminousPowers = {
            '110000 lm (1000W)': 110000,
            '3500 lm (300W)': 3500,
            '1700 lm (100W)': 1700,
            '800 lm (60W)': 800,
            '400 lm (40W)': 400,
            '180 lm (25W)': 180,
            '20 lm (4W)': 20,
            'Off': 0
        }

        const hemiLuminousIrradiances = {
            '0.0001 lx (Moonless Night)': 0.0001,
            '0.002 lx (Night Airglow)': 0.002,
            '0.5 lx (Full Moon)': 0.5,
            '3.4 lx (City Twilight)': 3.4,
            '50 lx (Living Room)': 50,
            '100 lx (Very Overcast)': 100,
            '350 lx (Office Room)': 350,
            '400 lx (Sunrise/Sunset)': 400,
            '1000 lx (Overcast)': 1000,
            '18000 lx (Daylight)': 18000,
            '50000 lx (Direct Sun)': 50000
        };

        const params = {
            shadows: true,
            exposure: 0.68,
            bulbPower: Object.keys(bulbLuminousPowers)[4],
            hemiIrradiance: Object.keys(hemiLuminousIrradiances)[0]
        }

        init();
        animate();

        function init() {
            clock = new THREE.Clock();

            const container = document.getElementById('container');

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(-4, 4, 2);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x505050);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.physicallyCorrectLights = true; // 物理效果正确的光照
            renderer.outputEncoding = THREE.sRGBEncoding; // 输出编码, 不知道什么用
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.minDistance = 1;
            controls.maxDistance = 20;

            const textureLoader = new THREE.TextureLoader();

            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            floorMaterial = new THREE.MeshStandardMaterial({
                roughness: 0.8,
                color: 0xffffff,
                metalness: 0.2,
                bumpScale: 0.0005
            });
            textureLoader.load('../textures/hardwood2_diffuse.jpg', function (map) {
                map.wrapS = THREE.RepeatWrapping;
                map.wrapT = THREE.RepeatWrapping;
                map.anisotropy = 4;
                // 加载的材质中使用了纹理时可以通过此属性控制纹理采样时的各向异性过滤程度, 在不同角度和细节上提高纹理的清晰度和细节
                map.repeat.set(10, 24);
                map.encoding = THREE.sRGBEncoding;
                // 指定纹理的颜色空间编码方式, 是指将颜色从物理空间转换到纹理空间的方式
                // 常见的编码方式有sRGB和Linear, 前者非线性后者线性
                // 特殊情况如需要精确的光照时可以将纹理的编码方式设置为 Linear, sRGB适合大多数情况.
                // sRGB将颜色值映射到标准RGB空间中, 暗部的亮度受到进一步压缩, 亮部的亮度被扩展, 亮度的整体对比效果会更加明显, 但在暗部细节上会损失精度
                // Linear中每个颜色分量的亮度与其对应的光强度成正比不会丢精度, 但是亮度对比没有sRGB强烈.
                floorMaterial.map = map; // 贴图直接赋值给材质的map属性
                // 将贴图挂载到材质
                floorMaterial.needsUpdate = true;
                // 在three.js中, 修改一个material的属性并不会发起自动更新, three在每次渲染前检查needsUpdate属性来判断是否需要更新material.
                // material会影响性能, 在完成全部的更改后调用, 而非频繁调用.
            })
            textureLoader.load('../textures/hardwood2_bump.jpg', function (map) {
                map.wrapS = THREE.RepeatWrapping;
                map.wrapT = THREE.RepeatWrapping;
                map.anisotropy = 4;
                map.repeat.set(10, 24);
                floorMaterial.bumpmap = map; // 凹凸贴图需要赋值给材质的bumpmap属性
                // 凹凸贴图用于在表面上创建凹凸不平的细节, 要被赋值给贴图的bump属性
                floorMaterial.needsUpdate = true;
            })
            textureLoader.load('../textures/hardwood2_roughness.jpg', function (map) {
                map.wrapS = THREE.RepeatWrapping;
                map.wrapT = THREE.RepeatWrapping;
                map.anisotropy = 4;
                map.repeat.set(10, 24);
                floorMaterial.roughnessMap = map; // 
                floorMaterial.needsUpdate = true;
            })
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.receiveShadow = true;
            floor.rotation.x = - Math.PI / 2.0;
            scene.add(floor);

            const cubeGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            cubeMaterial = new THREE.MeshStandardMaterial({
                roughness: 0.7, // 材质粗糙度
                color: 0xffffff, // 颜色
                bumpScale: 0.002, // 凹凸贴图会对材质产生多大影响
                metalness: 0.2 // 金属相似度
            })
            textureLoader.load('../textures/brick_diffuse.jpg', function (map) {
                map.wrapS = THREE.RepeatWrapping;
                map.wrapT = THREE.RepeatWrapping;
                map.anisotropy = 4;
                map.repeat.set(1, 1);
                map.encoding = THREE.sRGBEncoding;
                cubeMaterial.map = map;
                cubeMaterial.needsUpdate = true;
            });
            textureLoader.load('../textures/brick_bump.jpg', function (map) {
                map.wrapS = THREE.RepeatWrapping;
                map.wrapT = THREE.RepeatWrapping;
                map.anisotropy = 4;
                map.repeat.set(1, 1);
                cubeMaterial.bumpMap = map;
                cubeMaterial.needsUpdate = true;
            });
            const box0 = new THREE.Mesh(cubeGeometry, cubeMaterial);
            box0.position.set(-0.5, 0.25, -1);
            box0.castShadow = true;
            scene.add(box0);
            const box1 = new THREE.Mesh(cubeGeometry, cubeMaterial);
            box1.position.set(-0.5, 0.25, -1);
            box1.castShadow = true;
            scene.add(box1);
            const box2 = new THREE.Mesh(cubeGeometry, cubeMaterial);
            box2.position.set(-0.5, 0.25, -1);
            box2.castShadow = true;
            scene.add(box2);

            const ballGeometry = new THREE.SphereGeometry(0.25, 32, 32);
            ballMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.5,
                metalness: 1.0
            });
            textureLoader.load('../textures/planets/earth_atmos_2048.jpg', function (map) {
                map.anisotropy = 4;
                map.encoding = THREE.sRGBEncoding;
                ballMaterial.map = map;
                ballMaterial.needsUpdate = true;
            });
            textureLoader.load('../textures/planets/earth_specular_2048.jpg', function (map) {
                map.anisotropy = 4;
                map.encoding = THREE.sRGBEncoding;
                ballMaterial.metalnessMap = map;
                ballMaterial.needsUpdate = true;
            });
            const ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.castShadow = true;
            ball.position.set(1, 0.5, 0);
            scene.add(ball);

            const bulbGeometry = new THREE.SphereGeometry(0.02, 16, 8);
            bulbMaterial = new THREE.MeshStandardMaterial({
                emissive: 0xffffee,
                emissiveIntensity: 1,
                color: 0x000000
            })
            const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);

            bulbLight = new THREE.PointLight(0xffee88, 1, 100, 1.7);
            bulbLight.position.set(0, 5, 0);
            bulbLight.castShadow = true;
            bulbLight.add(bulb);
            scene.add(bulbLight); // bulbLight对象是灯泡主体

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            const t = clock.getElapsedTime(); // 可以依据sin/cos的值曲线变化规律加以干预形成周期性的变化
            bulbLight.position.y = Math.abs(Math.sin(t) + 1);
            renderer.shadowMap.enabled = true;
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>